#!/usr/bin/env node

/**
 * Generate Plugin Component Loaders Script
 * 
 * Auto-generates componentLoaderPaths.ts from plugin manifests.
 * Scans all plugins in packages/plugins/ and generates path mappings
 * for all components declared in plugin.manifest.json.
 * 
 * Usage:
 *   node scripts/generate-plugin-loaders.js
 *   npm run generate:loaders
 */

const fs = require('fs');
const path = require('path');

// ANSI color codes for console output
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  red: '\x1b[31m',
};

function log(message, color = colors.reset) {
  console.log(`${color}${message}${colors.reset}`);
}

function logSuccess(message) {
  log(`✓ ${message}`, colors.green);
}

function logWarning(message) {
  log(`⚠ ${message}`, colors.yellow);
}

function logError(message) {
  log(`✗ ${message}`, colors.red);
}

function logInfo(message) {
  log(`ℹ ${message}`, colors.blue);
}

// Configuration
const ROOT_DIR = path.resolve(__dirname, '..');
const PLUGINS_DIR = path.join(ROOT_DIR, 'packages', 'plugins');
const OUTPUT_FILE = path.join(ROOT_DIR, 'packages', 'core', 'config', 'plugins', 'componentLoaderPaths.ts');

/**
 * Common path patterns to try when finding component files
 * Patterns are tried in order, first match wins
 */
const PATH_PATTERNS = [
  // Pattern 1: components/{ComponentName}/{ComponentName}
  (componentName, pluginId) => `components/${componentName}/${componentName}`,
  
  // Pattern 2: components/{folder}/{ComponentName} (for nested structures)
  // We'll try common folders: topup, withdraw, shared, virtual-account, etc.
  (componentName, pluginId) => {
    const commonFolders = ['topup', 'withdraw', 'shared', 'virtual-account', 'topup-member'];
    for (const folder of commonFolders) {
      const testPath = `components/${folder}/${componentName}`;
      const fullPath = path.join(PLUGINS_DIR, pluginId, testPath);
      if (fs.existsSync(fullPath + '.tsx') || fs.existsSync(fullPath + '.ts')) {
        return testPath;
      }
    }
    return null;
  },
  
  // Pattern 3: components/{ComponentName} (flat structure)
  (componentName, pluginId) => `components/${componentName}`,
  
  // Pattern 4: {ComponentName}/{ComponentName} (root level, unlikely but possible)
  (componentName, pluginId) => `${componentName}/${componentName}`,
];

/**
 * Find component file path by trying common patterns
 */
function findComponentPath(pluginId, componentName) {
  const pluginDir = path.join(PLUGINS_DIR, pluginId);
  
  if (!fs.existsSync(pluginDir)) {
    return null;
  }
  
  // Try each pattern
  for (const pattern of PATH_PATTERNS) {
    const testPath = pattern(componentName, pluginId);
    if (!testPath) continue;
    
    const fullPath = path.join(pluginDir, testPath);
    
    // Check if file exists (try .tsx first, then .ts)
    if (fs.existsSync(fullPath + '.tsx')) {
      return testPath;
    }
    if (fs.existsSync(fullPath + '.ts')) {
      return testPath;
    }
  }
  
  return null;
}

/**
 * Generate TypeScript code for componentLoaderPaths.ts
 */
function generateTypeScriptCode(loaders) {
  const header = `/**
 * Component Loader Paths Configuration
 * 
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 * Generated by: npm run generate:loaders
 * 
 * This file is auto-generated from plugin manifests.
 * To regenerate, run: npm run generate:loaders
 * 
 * For manual edits or more details, see: PLUGIN_LOADERS.md
 */

export const COMPONENT_LOADER_PATHS: Record<string, Record<string, string>> = {`;

  const footer = `};`;

  // Generate entries for each plugin
  const entries = [];
  
  for (const [pluginId, components] of Object.entries(loaders)) {
    const componentEntries = [];
    
    for (const [componentName, componentPath] of Object.entries(components)) {
      componentEntries.push(`    ${componentName}: '${componentPath}',`);
    }
    
    entries.push(`  ${pluginId}: {`);
    entries.push(...componentEntries);
    entries.push(`  },`);
  }
  
  return [header, ...entries, footer].join('\n');
}

/**
 * Main function
 */
function generateLoaders() {
  logInfo('Starting plugin loader generation...\n');
  
  // Check if plugins directory exists
  if (!fs.existsSync(PLUGINS_DIR)) {
    logError(`Plugins directory not found: ${PLUGINS_DIR}`);
    process.exit(1);
  }
  
  // Get all plugin directories
  const plugins = fs.readdirSync(PLUGINS_DIR, { withFileTypes: true })
    .filter(dirent => dirent.isDirectory())
    .map(dirent => dirent.name);
  
  if (plugins.length === 0) {
    logWarning('No plugins found in packages/plugins/');
    return;
  }
  
  logInfo(`Found ${plugins.length} plugins: ${plugins.join(', ')}\n`);
  
  const allLoaders = {};
  const warnings = [];
  
  // Process each plugin
  for (const pluginId of plugins) {
    const manifestPath = path.join(PLUGINS_DIR, pluginId, 'plugin.manifest.json');
    
    if (!fs.existsSync(manifestPath)) {
      logWarning(`No manifest found for plugin: ${pluginId}`);
      continue;
    }
    
    try {
      const manifestContent = fs.readFileSync(manifestPath, 'utf8');
      const manifest = JSON.parse(manifestContent);
      
      const components = manifest.exports?.components || [];
      
      if (components.length === 0) {
        logWarning(`No components exported by plugin: ${pluginId}`);
        continue;
      }
      
      const pluginLoaders = {};
      let foundCount = 0;
      
      for (const componentName of components) {
        const componentPath = findComponentPath(pluginId, componentName);
        
        if (componentPath) {
          // Convert to relative path from packages/core/config/plugins/
          const relativePath = `../../../plugins/${pluginId}/${componentPath}`;
          pluginLoaders[componentName] = relativePath;
          foundCount++;
        } else {
          warnings.push(`Component "${componentName}" from plugin "${pluginId}" not found - please add manually to componentLoaderPaths.ts`);
        }
      }
      
      if (Object.keys(pluginLoaders).length > 0) {
        allLoaders[pluginId] = pluginLoaders;
        logSuccess(`Plugin "${pluginId}": ${foundCount}/${components.length} components mapped`);
      } else {
        logWarning(`No component paths found for plugin: ${pluginId}`);
      }
      
    } catch (error) {
      logError(`Error processing plugin ${pluginId}: ${error.message}`);
    }
  }
  
  // Generate TypeScript code
  if (Object.keys(allLoaders).length === 0) {
    logError('No component loaders generated. Please check plugin manifests.');
    process.exit(1);
  }
  
  const code = generateTypeScriptCode(allLoaders);
  
  // Write to file
  try {
    fs.writeFileSync(OUTPUT_FILE, code, 'utf8');
    logSuccess(`\nGenerated: ${path.relative(ROOT_DIR, OUTPUT_FILE)}`);
  } catch (error) {
    logError(`Failed to write file: ${error.message}`);
    process.exit(1);
  }
  
  // Show warnings
  if (warnings.length > 0) {
    logWarning(`\n⚠ ${warnings.length} warning(s):`);
    warnings.forEach(warning => logWarning(`  ${warning}`));
    logInfo('\nPlease manually add missing components to componentLoaderPaths.ts');
  }
  
  logSuccess('\n✓ Plugin loader generation completed!');
  logInfo('\nNext steps:');
  logInfo('  1. Review the generated file');
  logInfo('  2. Manually add any missing components if needed');
  logInfo('  3. Run: npm run generate:loaders (whenever you add new components)');
}

// Run
generateLoaders();

