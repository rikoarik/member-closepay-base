#!/usr/bin/env node

/**
 * Generate Plugin Component Loaders Script
 * 
 * Auto-generates componentLoaderPaths.ts from plugin manifests.
 * Scans all plugins in packages/plugins/ and generates path mappings
 * for all components declared in plugin.manifest.json.
 * 
 * Usage:
 *   node scripts/generate-plugin-loaders.js
 *   npm run generate:loaders
 */

const fs = require('fs');
const path = require('path');

// ANSI color codes for console output
const colors = {
  reset: '\x1b[0m',
  bright: '\x1b[1m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  red: '\x1b[31m',
};

function log(message, color = colors.reset) {
  console.log(`${color}${message}${colors.reset}`);
}

function logSuccess(message) {
  log(`✓ ${message}`, colors.green);
}

function logWarning(message) {
  log(`⚠ ${message}`, colors.yellow);
}

function logError(message) {
  log(`✗ ${message}`, colors.red);
}

function logInfo(message) {
  log(`ℹ ${message}`, colors.blue);
}

// Configuration
const ROOT_DIR = path.resolve(__dirname, '..');
const PLUGINS_DIR = path.join(ROOT_DIR, 'packages', 'plugins');
const OUTPUT_FILE = path.join(ROOT_DIR, 'packages', 'core', 'config', 'plugins', 'componentLoaderPaths.ts');
const PLUGIN_COMPONENT_LOADER_FILE = path.join(ROOT_DIR, 'packages', 'core', 'config', 'plugins', 'pluginComponentLoader.ts');

/**
 * Common path patterns to try when finding component files
 * Patterns are tried in order, first match wins
 */
const PATH_PATTERNS = [
  // Pattern 1: components/{ComponentName}/{ComponentName}
  (componentName, pluginId) => `components/${componentName}/${componentName}`,
  
  // Pattern 2: components/{folder}/{ComponentName} (for nested structures)
  // Scan all folders in components/ directory
  (componentName, pluginId) => {
    const componentsDir = path.join(PLUGINS_DIR, pluginId, 'components');
    if (!fs.existsSync(componentsDir)) {
      return null;
    }
    
    // Get all subdirectories in components/
    const subdirs = fs.readdirSync(componentsDir, { withFileTypes: true })
      .filter(dirent => dirent.isDirectory())
      .map(dirent => dirent.name);
    
    // Try each subdirectory
    for (const folder of subdirs) {
      const testPath = `components/${folder}/${componentName}`;
      const fullPath = path.join(PLUGINS_DIR, pluginId, testPath);
      if (fs.existsSync(fullPath + '.tsx') || fs.existsSync(fullPath + '.ts')) {
        return testPath;
      }
    }
    return null;
  },
  
  // Pattern 3: components/{ComponentName} (flat structure)
  (componentName, pluginId) => `components/${componentName}`,
  
  // Pattern 4: {ComponentName}/{ComponentName} (root level, unlikely but possible)
  (componentName, pluginId) => `${componentName}/${componentName}`,
];

/**
 * Find component file path by trying common patterns
 */
function findComponentPath(pluginId, componentName) {
  const pluginDir = path.join(PLUGINS_DIR, pluginId);
  
  if (!fs.existsSync(pluginDir)) {
    return null;
  }
  
  // Try each pattern
  for (const pattern of PATH_PATTERNS) {
    const testPath = pattern(componentName, pluginId);
    if (!testPath) continue;
    
    const fullPath = path.join(pluginDir, testPath);
    
    // Check if file exists (try .tsx first, then .ts)
    if (fs.existsSync(fullPath + '.tsx')) {
      return testPath;
    }
    if (fs.existsSync(fullPath + '.ts')) {
      return testPath;
    }
  }
  
  return null;
}

/**
 * Generate TypeScript code for componentLoaderPaths.ts
 */
function generateTypeScriptCode(loaders) {
  const header = `/**
 * Component Loader Paths Configuration
 * 
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 * Generated by: npm run generate:loaders
 * 
 * This file is auto-generated from plugin manifests.
 * To regenerate, run: npm run generate:loaders
 * 
 * For manual edits or more details, see: PLUGIN_LOADERS.md
 */

export const COMPONENT_LOADER_PATHS: Record<string, Record<string, string>> = {`;

  const footer = `};`;

  // Generate entries for each plugin
  const entries = [];
  
  for (const [pluginId, components] of Object.entries(loaders)) {
    const componentEntries = [];
    
    for (const [componentName, componentPath] of Object.entries(components)) {
      componentEntries.push(`    ${componentName}: '${componentPath}',`);
    }
    
    // Wrap plugin ID with quotes if it contains dash
    const pluginKey = pluginId.includes('-') ? `'${pluginId}'` : pluginId;
    
    entries.push(`  ${pluginKey}: {`);
    entries.push(...componentEntries);
    entries.push(`  },`);
  }
  
  return [header, ...entries, footer].join('\n');
}

/**
 * Generate TypeScript code for STATIC_COMPONENT_LOADERS in pluginComponentLoader.ts
 */
function generateStaticComponentLoadersCode(loaders) {
  const entries = [];
  
  for (const [pluginId, components] of Object.entries(loaders)) {
    const componentEntries = [];
    
    for (const [componentName, componentPath] of Object.entries(components)) {
      componentEntries.push(`    ${componentName}: () => import('${componentPath}'),`);
    }
    
    // Wrap plugin ID with quotes if it contains dash
    const pluginKey = pluginId.includes('-') ? `'${pluginId}'` : pluginId;
    entries.push(`  ${pluginKey}: {`);
    entries.push(...componentEntries);
    entries.push(`  },`);
  }
  
  return entries.join('\n');
}

/**
 * Update STATIC_COMPONENT_LOADERS in pluginComponentLoader.ts
 */
function updatePluginComponentLoader(loaders) {
  if (!fs.existsSync(PLUGIN_COMPONENT_LOADER_FILE)) {
    logWarning(`File not found: ${PLUGIN_COMPONENT_LOADER_FILE}`);
    return;
  }

  const fileContent = fs.readFileSync(PLUGIN_COMPONENT_LOADER_FILE, 'utf8');
  
  // Find the STATIC_COMPONENT_LOADERS block using regex
  const regex = /(const STATIC_COMPONENT_LOADERS: Record<string, Record<string, \(\) => Promise<any>>> = \{)([\s\S]*?)(\};)/;
  const match = fileContent.match(regex);
  
  if (!match) {
    logWarning('Could not find STATIC_COMPONENT_LOADERS block in pluginComponentLoader.ts');
    return;
  }
  
  // Generate new STATIC_COMPONENT_LOADERS code
  const newLoadersCode = generateStaticComponentLoadersCode(loaders);
  
  // Replace the block content (keep the declaration and closing brace)
  const newContent = fileContent.replace(
    regex,
    `$1\n${newLoadersCode}\n$3`
  );
  
  // Write back to file
  try {
    fs.writeFileSync(PLUGIN_COMPONENT_LOADER_FILE, newContent, 'utf8');
    logSuccess(`Updated: ${path.relative(ROOT_DIR, PLUGIN_COMPONENT_LOADER_FILE)}`);
  } catch (error) {
    logError(`Failed to update pluginComponentLoader.ts: ${error.message}`);
  }
}

/**
 * Main function
 */
function generateLoaders() {
  logInfo('Starting plugin loader generation...\n');
  
  // Check if plugins directory exists
  if (!fs.existsSync(PLUGINS_DIR)) {
    logError(`Plugins directory not found: ${PLUGINS_DIR}`);
    process.exit(1);
  }
  
  // Get all plugin directories
  const plugins = fs.readdirSync(PLUGINS_DIR, { withFileTypes: true })
    .filter(dirent => dirent.isDirectory())
    .map(dirent => dirent.name);
  
  if (plugins.length === 0) {
    logWarning('No plugins found in packages/plugins/');
    return;
  }
  
  logInfo(`Found ${plugins.length} plugins: ${plugins.join(', ')}\n`);
  
  const allLoaders = {};
  const warnings = [];
  
  // Process each plugin
  for (const pluginId of plugins) {
    const manifestPath = path.join(PLUGINS_DIR, pluginId, 'plugin.manifest.json');
    
    if (!fs.existsSync(manifestPath)) {
      logWarning(`No manifest found for plugin: ${pluginId}`);
      continue;
    }
    
    try {
      const manifestContent = fs.readFileSync(manifestPath, 'utf8');
      const manifest = JSON.parse(manifestContent);
      
      let components = manifest.exports?.components || [];
      
      // Also include screens if they exist
      if (manifest.exports?.screens) {
        // screens is an object { "ExportName": "ComponentName" }
        // We want the ComponentName values (the actual component names, not export names)
        const screenComponents = Object.values(manifest.exports.screens);
        components = [...components, ...screenComponents];
      }

      // Also include tabs if they exist
      if (manifest.exports?.tabs) {
        const tabComponents = Object.values(manifest.exports.tabs);
        components = [...components, ...tabComponents];
      }

      // Also include widgets if they exist
      if (manifest.exports?.widgets) {
        const widgetComponents = Object.values(manifest.exports.widgets);
        components = [...components, ...widgetComponents];
      }
      
      // Remove duplicates
      components = [...new Set(components)];
      
      // Also check if any component names in exports.components are actually screen export names
      // If so, resolve them to actual component names from exports.screens
      if (manifest.exports?.screens) {
        const screenMap = manifest.exports.screens;
        components = components.map(compName => {
          // If this is an export name (key) in screens, use the actual component name (value)
          return screenMap[compName] || compName;
        });
      }
      
      if (components.length === 0) {
        logWarning(`No components exported by plugin: ${pluginId}`);
        continue;
      }
      
      const pluginLoaders = {};
      let foundCount = 0;
      
      for (const componentName of components) {
        const componentPath = findComponentPath(pluginId, componentName);
        
        if (componentPath) {
          // Convert to relative path from packages/core/config/plugins/
          const relativePath = `../../../plugins/${pluginId}/${componentPath}`;
          pluginLoaders[componentName] = relativePath;
          foundCount++;
        } else {
          warnings.push(`Component "${componentName}" from plugin "${pluginId}" not found - please add manually to componentLoaderPaths.ts`);
        }
      }
      
      if (Object.keys(pluginLoaders).length > 0) {
        allLoaders[pluginId] = pluginLoaders;
        logSuccess(`Plugin "${pluginId}": ${foundCount}/${components.length} components mapped`);
      } else {
        logWarning(`No component paths found for plugin: ${pluginId}`);
      }
      
    } catch (error) {
      logError(`Error processing plugin ${pluginId}: ${error.message}`);
    }
  }
  
  // Generate TypeScript code
  if (Object.keys(allLoaders).length === 0) {
    logError('No component loaders generated. Please check plugin manifests.');
    process.exit(1);
  }
  
  const code = generateTypeScriptCode(allLoaders);
  
  // Write componentLoaderPaths.ts
  try {
    fs.writeFileSync(OUTPUT_FILE, code, 'utf8');
    logSuccess(`\nGenerated: ${path.relative(ROOT_DIR, OUTPUT_FILE)}`);
  } catch (error) {
    logError(`Failed to write file: ${error.message}`);
    process.exit(1);
  }
  
  // Update STATIC_COMPONENT_LOADERS in pluginComponentLoader.ts
  updatePluginComponentLoader(allLoaders);
  
  // Show warnings
  if (warnings.length > 0) {
    logWarning(`\n⚠ ${warnings.length} warning(s):`);
    warnings.forEach(warning => logWarning(`  ${warning}`));
    logInfo('\nPlease manually add missing components to componentLoaderPaths.ts');
  }
  
  logSuccess('\n✓ Plugin loader generation completed!');
  logInfo('\nNext steps:');
  logInfo('  1. Review the generated files');
  logInfo('  2. Manually add any missing components if needed');
  logInfo('  3. Run: npm run generate:loaders (whenever you add new components)');
}

// Run
generateLoaders();

